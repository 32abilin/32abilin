










































setting ->general->advance ->biderectional(use two for this)

settings -> storage -> controller-> click the disk -> choose create virutal 
			-> add button -> C: -> programfile -> oracle -> virutal box (vboxGA)
			
Now open the ubuntu virual box
	select vboxlinuxadditions disc in left corner task menu
	open the terminal inside the file path
	ls
	sudo ./VBoxLinuxAdditions.run 
	restart ubuntu
	
	
	
	
//Run the NASM
	nasm -f elf fileName.asm
	ld -m elf_i386 -s -o fileName fileName.o
	./fileName
	
	


//addition, multipication, substraction, division three single input numbers (select options)
SYS_EXIT equ 1
SYS_READ equ 3
SYS_WRITE equ 4
STDIN equ 0
STDOUT equ 1

section .data
    msg1 db 10, '-Basic Operators-', 10, 0
    lmsg1 equ $ - msg1

    msg2 db 10, 'Enter number 1: ', 0
    lmsg2 equ $ - msg2

    msg3 db 'Enter number 2: ', 0
    lmsg3 equ $ - msg3

    msg11 db 'Enter number 3: ', 0
    lmsg11 equ $ - msg11

    msg4 db 10, '1. Add', 10, 0
    lmsg4 equ $ - msg4

    msg5 db '2. Subtract', 10, 0
    lmsg5 equ $ - msg5

    msg6 db '3. Multiply', 10, 0
    lmsg6 equ $ - msg6

    msg7 db '4. Divide', 10, 0
    lmsg7 equ $ - msg7

    msg8 db 'Operation: ', 0
    lmsg8 equ $ - msg8

    msg9 db 10, 'Result: ', 0
    lmsg9 equ $ - msg9

    msg10 db 10, 'Invalid Option', 10, 0
    lmsg10 equ $ - msg10

    nlinea db 10, 10, 0
    lnlinea equ $ - nlinea

section .bss
    opc resb 2
    num1 resb 2
    num2 resb 2
    num3 resb 2
    result resb 2

section .text
    global _start

_start:
    mov eax, 4
    mov ebx, 1
    mov ecx, msg1
    mov edx, lmsg1
    int 0x80

    ; Read first number
    mov eax, 4
    mov ebx, 1
    mov ecx, msg2
    mov edx, lmsg2
    int 0x80

    mov eax, 3
    mov ebx, 0
    mov ecx, num1
    mov edx, 2
    int 0x80

    ; Read second number
    mov eax, 4
    mov ebx, 1
    mov ecx, msg3
    mov edx, lmsg3
    int 80h

    mov eax, 3
    mov ebx, 0
    mov ecx, num2
    mov edx, 2
    int 0x80

    ; Read third number
    mov eax, 4
    mov ebx, 1
    mov ecx, msg11
    mov edx, lmsg11
    int 0x80

    mov eax, 3
    mov ebx, 0
    mov ecx, num3
    mov edx, 2
    int 0x80

    ; Display operation options
    mov eax, 4
    mov ebx, 1
    mov ecx, msg4
    mov edx, lmsg4
    int 0x80

    mov eax, 4
    mov ebx, 1
    mov ecx, msg5
    mov edx, lmsg5
    int 0x80

    mov eax, 4
    mov ebx, 1
    mov ecx, msg6
    mov edx, lmsg6
    int 0x80

    mov eax, 4
    mov ebx, 1
    mov ecx, msg7
    mov edx, lmsg7
    int 0x80

    ; Read operation choice
    mov eax, 4
    mov ebx, 1
    mov ecx, msg8
    mov edx, lmsg8
    int 0x80

    mov ebx, 0
    mov ecx, opc
    mov edx, 2
    mov eax, 3
    int 0x80

    mov ah, [opc]
    sub ah, '0'

    cmp ah, 1
    je add
    cmp ah, 2
    je subtract
    cmp ah, 3
    je multiply
    cmp ah, 4
    je divide

    ; Invalid option selected
    mov eax, 4
    mov ebx, 1
    mov ecx, msg10
    mov edx, lmsg10
    int 80h

    jmp exit

add:
    ; Add numbers
    mov al, [num1]
    mov bl, [num2]
    mov cl, [num3]
    sub al, '0'
    sub bl, '0'
    sub cl, '0'
    add al, bl
    add al, cl
    add al, '0'
    mov [result], al
    jmp display_result

subtract:
    ; Subtract numbers
    mov al, [num1]
    mov bl, [num2]
    mov cl, [num3]
    sub al, '0'
    sub bl, '0'
    sub cl, '0'
    sub al, bl
    sub al, cl
    add al, '0'
    mov [result], al
    jmp display_result

multiply:
    ; Multiply numbers
    mov al, [num1]
    mov bl, [num2]
    mov cl, [num3]
    sub al, '0'
    sub bl, '0'
    sub cl, '0'
    mul bl
    mul cl
    add ax, '0'
    mov [result], ax
    jmp display_result

divide:
    ; Divide numbers
    mov al, [num1]
    mov bl, [num2]
    mov cl, [num3]
    mov dx, 0
    mov ah, 0
    sub al, '0'
    sub bl, '0'
    sub cl, '0'
    div bl
    div cl
    add ax, '0'
    mov [result], ax
    jmp display_result

display_result:
    ; Display result
    mov eax, 4
    mov ebx, 1
    mov ecx, msg9
    mov edx, lmsg9
    int 0x80

    mov eax, 4
    mov ebx, 1
    mov ecx, result
    mov edx, 1
    int 0x80

    jmp exit

exit:
    ; Exit program
    mov eax, 4
    mov ebx, 1
    mov ecx, nlinea
    mov edx, lnlinea
    int 0x80

    mov eax, 1
    mov ebx, 0
    int 0x80

	
	
	
	
// print******
		*****
		****
		***
		**
		*
section .data
	star db '*'
	line db 0xa
	
section .text
	global _start
	_start:
	mov ecx,6    ;6 stars
	
	L1:
		push ecx
	
	L2:
		push ecx
		
		mov edx,1
		mov ecx,star
		mov ebx,1
		mov eax,4
		int 0x80
		
		pop ecx
		
		loop L2
		
		mov edx,1
		mov ecx,line
		mov ebx,1
		mov eax,4
		int 0x80
		
		pop ecx
		
		loop L1
		
		mov eax,1
		int 0x80


//print ******
        ******
        ******
	    ******
		******
		******
section .data
	star 	DB '*'
	newLine DB 0xa	
section .text
	global _start
_start:
	mov ecx,6 ; lines 6	
q7:	
	push ecx
	mov ecx,6 ;stars 6 for one line
	q1:
		push ecx
		
		mov eax,4
		mov ebx,1
		mov ecx,star
		mov edx,1
		
		int 0x80
		
		pop ecx
		loop q1	
	mov eax,4
	mov ebx,1
	mov ecx,newLine
	mov edx,1
	
	int 0x80
	pop ecx
	loop q7
	mov eax,1
	int 80h



//print 
* 
* * 
* * * 
* * * * 
* * * * * 
* * * * * *
section .data
    star db '*', ' ' 
    line db 0xa      

section .text
    global _start
    _start:
    mov ecx, 1    

L1:
    push ecx     

L2:
    push ecx     

    mov edx, 2    
    mov ecx, star 
    mov ebx, 1  
    mov eax, 4  
    int 0x80    

    pop ecx       
    loop L2      

    mov edx, 1    
    mov ecx, line 
    mov ebx, 1   
    mov eax, 4   
    int 0x80    

    pop ecx     
    inc ecx       
    cmp ecx, 7   
    jl L1       

    mov eax, 1   
    xor ebx, ebx 
    int 0x80      


	
//print one number (example: 5)
section .data
    number db '5', 0  

section .text
    global _start

    _start:
        mov eax, 4         
        mov ebx, 1         
        mov ecx, number    
        mov edx, 1         
        int 0x80          

        ; Exit the program
        mov eax, 1         
        xor ebx, ebx       
        int 0x80           

//print 3to9 3456789
section .text
    global _start 
_start: 

    mov ecx, 7 ; Set loop counter to 7 (for numbers 3 to 9)
    mov eax, '3' 

l1:
    mov [num], eax ; Store the current digit in the memory
    mov eax, 4 ; System call number for write
    mov ebx, 1 ; File descriptor (stdout)
    push ecx ; Save loop counter

    mov ecx, num 
    mov edx, 1 
    int 0x80 

    mov eax, [num] 
    inc eax 
    mov [num], eax 
    pop ecx 
    loop l1 

    mov eax, 1 
    int 0x80 

section .bss
    num resb 1
	
	

//find large number
section	.text
   global _start         

_start:	                 
   mov   ecx, [num1]
   cmp   ecx, [num2]
   jg    check_third_num
   mov   ecx, [num2]
   
	check_third_num:

   cmp   ecx, [num3]
   jg    _exit
   mov   ecx, [num3]
   
	_exit:
   
   mov   [largest], ecx
   mov   ecx,msg
   mov   edx, len
   mov   ebx,1	
   mov   eax,4	
   int   0x80	
	
   mov   ecx,largest
   mov   edx, 2
   mov   ebx,1	
   mov   eax,4	
   int   0x80	
    
   mov   eax, 1
   int   80h

section	.data
   
   msg db "The largest digit is: ", 0xA,0xD 
   len equ $- msg 
   num1 dd '40'
   num2 dd '20'
   num3 dd '30'

segment .bss
   largest resb 2
   
   
   
   
   
   
//print Hello, programmers! Welcome to the world of, Linux assembly programming!
SYS_EXIT equ 1
SYS_WRITE equ 4
STDIN equ 0
STDOUT equ 1
section .text
	global main 
main: 
	mov eax, SYS_WRITE
	mov ebx, STDOUT
	mov ecx, msg1
	mov edx, len1
	int 0x80
	
	mov eax, SYS_WRITE
	mov ebx, STDOUT
	mov ecx, msg2
	mov edx, len2
	int 0x80
	
	mov eax, SYS_WRITE
	mov ebx, STDOUT
	mov ecx, msg3
	mov edx, len3
	int 0x80
	
	mov eax,SYS_EXIT 
	int 0x80 
section .data
	msg1 db 'Hello, programmers!',0xA,0xD
	len1 equ $ - msg1
	msg2 db 'Welcome to the world of,', 0xA,0xD
	len2 equ $ - msg2
	msg3 db 'Linux assembly programming! '
	len3 equ $- msg3
	
	
	
	
	
//nine stars print 
section .text
	global main 
main: 
	mov edx,len 
	mov ecx,msg 
	mov ebx,1 
	mov eax,4 
	int 0x80

	mov edx,9
	mov ecx,s2
	mov ebx,1
	mov eax,4
	int 0x80
	mov eax,1
	int 0x80
section .data
	msg db 'Nine Stars', 0xa 
	len equ $ - msg
	s2 times 9 db '*'
	
	
	
	
	
	
//enter number and display 
section .data 
	userMsg db 'Please enter a number: ' 
	lenUserMsg equ $-userMsg 
	dispMsg db 'You have entered: '
	lenDispMsg equ $-dispMsg
section .bss 
	num resb 5
section .text 
	global main
main:
	
	mov eax, 4
	mov ebx, 1
	mov ecx, userMsg
	mov edx, lenUserMsg
	int 80h
	
	mov eax, 3
	mov ebx, 2
	mov ecx, num
	mov edx, 5 
	int 80h
	
	mov eax, 4
	mov ebx, 1
	mov ecx, dispMsg
	mov edx, lenDispMsg
	int 80h
	
	mov eax, 4
	mov ebx, 1
	mov ecx, num
	mov edx, 5
	int 80h
; Exit code
	mov eax, 1
	mov ebx, 0
	int 80h
	
	
	
	
//Write assembly language code for stores a name 'Zara Ali' in the data section of the 
memory. Then changes its value to another name 'Nuha Ali' and displays both the names.
section .data
    name db 'Zara Ali', 0 

section .text
    global _start

_start:
    
    mov eax, 4         
    mov ebx, 1         
    mov ecx, name      
    mov edx, 8      
    int 0x80         

    
    mov eax, name      
    mov byte [eax], 'N' 
    
    
    mov eax, 4      
    mov ebx, 1     
    mov ecx, name   
    mov edx, 8   
    int 0x80    

   
    mov eax, 1       
    xor ebx, ebx   
    int 0x80    




//Write assembly language code for asks two digits from the user, stores the digits in the 
EAX and EBX register respectively, adds the values, stores the result in a memory location 
'res' and finally displays the result.
Enter a digit: 
3 
Please enter a second digit: 
4 
The sum is: 
7

SYS_EXIT equ 1
SYS_READ equ 3
SYS_WRITE equ 4
STDIN equ 0
STDOUT equ 1
segment .data
	msg1 db "Enter a digit ", 0xA,0xD
	len1 equ $- msg1
	msg2 db "Please enter a second digit", 0xA,0xD
	len2 equ $- msg2
	msg3 db "The sum is: "
	len3 equ $- msg3
segment .bss
	num1 resb 2
	num2 resb 2
	res resb 1
section .text
	global main 
main: 
	mov eax, SYS_WRITE
	mov ebx, STDOUT
	mov ecx, msg1
	mov edx, len1
	int 0x80
	
	mov eax, SYS_READ
	mov ebx, STDIN
	mov ecx, num1
	mov edx, 2
	int 0x80
	
	mov eax, SYS_WRITE
	mov ebx, STDOUT
	mov ecx, msg2
	mov edx, len2
	int 0x80
	
	mov eax, SYS_READ
	mov ebx, STDIN
	mov ecx, num2
	mov edx, 2
	int 0x80
	
	mov eax, SYS_WRITE
	mov ebx, STDOUT
	mov ecx, msg3
	mov edx, len3
	int 0x80

	mov eax, [num1]
	sub eax, '0'
	mov ebx, [num2]
	sub ebx, '0'
	add eax, ebx
	add eax, '0'
	mov [res], eax

	mov eax, SYS_WRITE
	mov ebx, STDOUT
	mov ecx, res
	mov edx, 1
	int 0x80
exit:
	mov eax, SYS_EXIT
	xor ebx, ebx
	int 0x80



//Write assembly language code for divides 8 with 2. The dividend 8 is stored in the 16 bit 
AX register and the divisor 2 is stored in the 8 bit BL register.
section .text
	global main 
main: 
	mov ax,'8'
	sub ax, '0'
	mov bl, '2'
	sub bl, '0'
	div bl
	add ax, '0'
	mov [res], ax
	mov ecx,msg
	mov edx, len
	mov ebx,1 
	mov eax,4 
	int 0x80 
	
	mov ecx,res
	mov edx, 1
	mov ebx,1 
	mov eax,4 
	int 0x80 
	mov eax,1 
	int 0x80 
section .data
	msg db "The result is:", 0xA,0xD
	len equ $- msg
segment .bss
	res resb 1



//Write assembly language code for check whether a given number is odd or even
section .text
   global _start            
	
_start:                     
   mov   ax,   8h           
   and   ax, 1              
   jz    evnn
   mov   eax, 4             
   mov   ebx, 1             
   mov   ecx, odd       
   mov   edx, len2          
   int   0x80               
   jmp   outprog

evnn:   
  
	mov   ah,  09h
	mov   eax, 4             
	mov   ebx, 1            
	mov   ecx, even     
	mov   edx, len1         
	int   0x80             

outprog:

	mov   eax,1              
	int   0x80               

section   .data
	even  db  'Even Number!' 
	len1  equ  $ - even 
	odd db  'Odd Number!'   
	len2  equ  $ - odd
	
	

//Write assembly language code for multiplies 3 with 2, and displays the result
section .text
	global main 
main: 
	mov al,'3'
	sub al, '0'
	mov bl, '2'
	sub bl, '0'
	mul bl
	add al, '0'
	mov [res], al
	mov ecx,msg
	mov edx, len
	mov ebx,1 
	mov eax,4 
	int 0x80 
	
	mov ecx,res
	mov edx, 1
	mov ebx,1 
	mov eax,4 
	int 0x80 
	mov eax,1 
	int 0x80 
section .data
	msg db "The result is:", 0xA,0xD
	len equ $- msg
segment .bss
	res resb 1




	
	
//Write assembly language code for adds up two 5-digit decimal numbers and displays the sum.
section .text
	global main 
main: 
	mov esi, 4 
	mov ecx, 5 
	clc
add_loop:
	mov al, [num1 + esi]
	adc al, [num2 + esi]
	aaa
	pushf
	or al, 30h
	popf
	mov [sum + esi], al
	dec esi
	loop add_loop
	mov edx,len 
	mov ecx,msg 
	mov ebx,1 
	mov eax,4 
	int 0x80 
	mov edx,5 
	mov ecx,sum 
	mov ebx,1 
	mov eax,4 
	int 0x80 
	mov eax,1 
	int 0x80 
section .data
	msg db 'The Sum is:',0xa
	len equ $ - msg
	num1 db '25142'
	num2 db '23126'
	sum db ' '
	
	
	
	
//Write assembly language code for defining a 3 element array x, which stores three values. 2, 3 and 4. 
It adds the values in the array and displays the sum 9.
section .text
	global main 
main:
	mov eax,3 
	mov ebx,0 
	mov ecx, x 
top: 	
	add ebx, [ecx]
	add ecx,1 
	dec eax 
	jnz top 
done:
	add ebx, '0'
	mov [sum],byte ebx 
display:
	mov edx,1 
	mov ecx, sum 
	mov ebx, 1 
	mov eax, 4 
	int 0x80 
	mov eax, 1 
	int 0x80 
section .data
	global x
x:
	db 2
	db 4
	db 3
sum:
	db 0
	
	
	
	
	
//Write assembly language code for calculating factorial to any given number
section .text
global main 
main: 

mov bx, 3 
 call proc_fact
 add ax, 30h
 mov [fact], ax

 mov edx,len 
 mov ecx,msg 
 mov ebx,1 
 mov eax,4 
 int 0x80 

 mov edx,1 
 mov ecx,fact 
 mov ebx,1 
 mov eax,4 
 int 0x80 

 mov eax,1 
 int 0x80 

proc_fact:
 cmp bl, 1
 jg do_calculation
 mov ax, 1
 ret

do_calculation:
 dec bl
 call proc_fact
 inc bl
 mul bl 
 ret

section .data
msg db 'Factorial 3 is:',0xa
len equ $ - msg

section .bss
fact resb 1




//Write assembly language code for Creates and open a file named myfile.txt, and writes a text 'Welcome to Tutorials Point' in this file. 
Then program reads from the file and stores the data into a buffer named info. Displays the text as stored in info.
section	.text
   global _start       
	
_start:                  
  
   mov  eax, 8
   mov  ebx, file_name
   mov  ecx, 0777        
   int  0x80            
	
   mov [fd_out], eax
    
   mov	edx,len          
   mov	ecx, msg        
   mov	ebx, [fd_out]   
   mov	eax,4            
   int	0x80             
	
   mov eax, 6
   mov ebx, [fd_out]
     
   mov eax, 4
   mov ebx, 1
   mov ecx, msg_done
   mov edx, len_done
   int  0x80
    
   mov eax, 5
   mov ebx, file_name
   mov ecx, 0            
   mov edx, 0777         
   int  0x80
	
   mov  [fd_in], eax
    
   mov eax, 3
   mov ebx, [fd_in]
   mov ecx, info
   mov edx, 26
   int 0x80
    
   mov eax, 6
   mov ebx, [fd_in]
   int  0x80    
	
   ; print the info 
   mov eax, 4
   mov ebx, 1
   mov ecx, info
   mov edx, 26
   int 0x80
       
   mov	eax,1            
   int	0x80             

section	.data
file_name db 'myfile.txt'
msg db 'Welcome to Tutorials Point'
len equ  $-msg

msg_done db 'Written to file', 0xa
len_done equ $-msg_done

section .bss
fd_out resb 1
fd_in  resb 1
info resb  26

